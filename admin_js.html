<script>
  /* === 表示対象期間 === */
  const _now = new Date();
  const startYear = _now.getFullYear();
  const startMonth = _now.getMonth() + 1;
  const monthsCount = 4;

  /* === 状態 === */
  let currentYear = startYear,
    currentMonth = startMonth;
  let schedule = {},
    attendance = {},
    holidays = {},
    roster = [];
  let unsavedPatch = {};
  let adminChart = null;

  /* === 時間リスト === */
  const HH = halfHourList(6, 21);

  /* === キャッシュ === */
  const ADMIN_CACHE_VER = "v2"; 
  const adminCacheKey = (y, m) => `club_admin_cache_${ADMIN_CACHE_VER}_${y}-${('0'+m).slice(-2)}`;

  function readAdminCache(y, m) {
    try {
      const s = localStorage.getItem(adminCacheKey(y, m));
      return s ? JSON.parse(s) : null;
    } catch (e) {
      return null;
    }
  }

  function writeAdminCache(y, m, data) {
    try {
      localStorage.setItem(adminCacheKey(y, m), JSON.stringify({
        ts: Date.now(),
        data
      }));
    } catch (e) {}
  }

  /* === 初期化 === */
  (function init() {
    buildTabs();
    document.getElementById("qMorningOn").onclick = () => applyQuick("M_ON");
    document.getElementById("qAfternoonOn").onclick = () => applyQuick("A_ON");
    document.getElementById("qAfterOn").onclick = () => applyQuick("F_ON");
    document.getElementById("qAllOff").onclick = () => applyQuick("ALL_OFF");
    document.getElementById("qUndecidedOff").onclick = () => applyQuick("UNDECIDED_OFF");
    document.getElementById("qClearCheck").onclick = () => document.querySelectorAll('#weekdayGroup input:checked').forEach(el => el.checked = false);
    document.getElementById("saveAllBtn").onclick = () => flushPatch();
    loadMonth();
  })();
  
  function setLoading(on) {
    const ov = document.getElementById('loadingOverlay');
    if (!ov) return;
    ov.classList.toggle('show', !!on);
  }

  function renderSkeletons() {
     const cont = document.getElementById("calendar");
     cont.innerHTML = "";
     cont.innerHTML = '<div style="padding:2em;text-align:center;color:#999;">Loading...</div>';
  }

  /* === タブ === */
  function visibleMonths() {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const vis = [];
    for (let i = 0; i < monthsCount; i++) {
      let m = startMonth + i,
        y = startYear;
      if (m > 12) {
        m -= 12;
        y += 1;
      }
      const last = new Date(y, m, 0);
      last.setHours(0, 0, 0, 0);
      if (last >= today) vis.push({
        y,
        m
      });
    }
    return vis;
  }

  function buildTabs() {
    const tabs = document.getElementById("tabs");
    const vis = visibleMonths();
    tabs.innerHTML = "";
    if (!vis.length) {
      tabs.innerHTML = '<div style="padding:1em;color:#8a6b55;text-align:center;">対象月がありません。</div>';
      return;
    }
    currentYear = vis[0].y;
    currentMonth = vis[0].m;
    vis.forEach((o, idx) => {
      const el = document.createElement("div");
      el.className = "tab" + (idx === 0 ? " active" : "");
      el.textContent = `${o.y}年${o.m}月`;
      el.dataset.year = o.y;
      el.dataset.month = o.m;
      el.onclick = () => switchTab(el);
      el.onkeypress = (e) => {
        if (e.key === "Enter" || e.key === " ") switchTab(el);
      };
      tabs.appendChild(el);
    });
  }

  function switchTab(el) {
    const go = () => {
      document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
      el.classList.add("active");
      currentYear = parseInt(el.dataset.year, 10);
      currentMonth = parseInt(el.dataset.month, 10);
      loadMonth();
    };
    if (Object.keys(unsavedPatch).length > 0) {
      flushPatch(null, go);
    } else {
      go();
    }
  }

  function markDirty() {
    document.getElementById("saveAllBtn").classList.toggle("dirty", Object.keys(unsavedPatch).length > 0);
  }

  function queuePatch(day, fields) {
    unsavedPatch[day] = Object.assign({}, unsavedPatch[day] || {}, fields);
    markDirty();
  }

  function setStatus(msg) {
    const el = document.getElementById("status");
    el.textContent = msg || "";
    if (!msg) return;
    setTimeout(() => {
      if (el.textContent === msg) el.textContent = "";
    }, 2000);
  }

  /* === データ読み込み === */
  function loadMonth() {
    renderSkeletons();
    
    const cached = readAdminCache(currentYear, currentMonth);
    if (cached && cached.data) {
      schedule = cached.data.schedule || {};
      attendance = cached.data.attendance || {};
      holidays = cached.data.holidays || {};
      roster = cached.data.roster || [];
      unsavedPatch = {};
      markDirty();
      renderOverviewCalendar();
      render(); 
    }

    google.script.run.withSuccessHandler(res => {
      schedule = res.schedule || {};
      attendance = res.attendance || {};
      holidays = res.holidays || {};
      roster = res.roster || [];
      unsavedPatch = {};
      markDirty();
      renderOverviewCalendar();
      render(); 
      writeAdminCache(currentYear, currentMonth, {
        schedule,
        attendance,
        holidays,
        roster
      });
      prefetchNextMonth();
    }).withFailureHandler(err => {
      if (!cached) {
        alert("データの読み込みに失敗しました。再読み込みしてください。");
      }
    }).getAdminData(currentYear, currentMonth);
  }

  function prefetchNextMonth() {
    let y = currentYear,
      m = currentMonth + 1;
    if (m > 12) {
      m = 1;
      y += 1;
    }
    const endMonth = startMonth + monthsCount - 1;
    const maxY = startYear + Math.floor((endMonth - 1) / 12);
    const maxM = ((endMonth - 1) % 12) + 1;
    const cmp = (y1, m1, y2, m2) => (y1 === y2 ? m1 - m2 : y1 - y2);
    if (cmp(y, m, maxY, maxM) > 0) return;
    if (readAdminCache(y, m)) return;
    google.script.run.withSuccessHandler(res => {
      writeAdminCache(y, m, {
        schedule: res.schedule || {},
        attendance: res.attendance || {},
        holidays: res.holidays || {},
        roster: res.roster || []
      });
    }).getAdminData(y, m);
  }

  function defaultAfterTimeRangeForDay(day) {
    const w = new Date(currentYear, currentMonth - 1, day).getDay();
    if (w === 1 || w === 2 || w === 5) return "16:00~18:00";
    if (w === 3 || w === 4) return "15:00~17:00";
    return "";
  }

  /* === 壁掛けカレンダー描画 (月曜始まり) === */
  function renderOverviewCalendar() {
    const container = document.getElementById("overviewCalendar");
    container.innerHTML = "";
    
    const grid = document.createElement("div");
    grid.className = "calendar-grid";
    
    const weeks = ["月","火","水","木","金","土","日"];
    weeks.forEach((w, i) => {
      const el = document.createElement("div");
      el.className = "cal-header";
      if(i === 5) el.classList.add("sat");
      if(i === 6) el.classList.add("sun");
      el.textContent = w;
      grid.appendChild(el);
    });

    const lastDate = new Date(currentYear, currentMonth, 0).getDate();
    const firstDayOfWeek = new Date(currentYear, currentMonth - 1, 1).getDay();
    const emptyCells = (firstDayOfWeek + 6) % 7;

    for(let i=0; i<emptyCells; i++){
      const empty = document.createElement("div");
      grid.appendChild(empty);
    }

    const today = new Date();
    const isThisMonth = (today.getFullYear() === currentYear && (today.getMonth()+1) === currentMonth);
    const todayD = today.getDate();

    for(let d=1; d<=lastDate; d++){
      const cell = document.createElement("div");
      cell.className = "cal-cell";
      cell.textContent = d;
      
      if(isThisMonth && d === todayD) {
        cell.classList.add("today");
      }

      const sch = schedule[d];
      let statusClass = "status-undecided";
      if(sch) {
        if(sch.off) statusClass = "status-off";
        else if(sch.morning || sch.afternoon || sch.after) statusClass = "status-active";
      }
      cell.classList.add(statusClass);

      const dot = document.createElement("div");
      dot.className = "cal-dot";
      cell.appendChild(dot);

      cell.onclick = () => {
        const target = document.getElementById("list-day-" + d);
        if(target) {
          target.scrollIntoView({ behavior: "smooth", block: "start" });
          target.style.transition = "background-color 0.5s";
          const originalBg = target.style.backgroundColor;
          target.style.backgroundColor = "#fff9c4"; 
          setTimeout(() => {
            target.style.backgroundColor = originalBg;
          }, 1000);
        }
      };

      grid.appendChild(cell);
    }
    container.appendChild(grid);
  }

  /* === リストUI描画 === */
  function render() {
    renderDashboard();
    const cont = document.getElementById("calendar");
    cont.innerHTML = "";
    const last = new Date(currentYear, currentMonth, 0).getDate();
    const frag = document.createDocumentFragment();
    const todayDate = new Date();
    const isThisMonth = (currentYear === todayDate.getFullYear() && currentMonth === (todayDate.getMonth()+1));
    const todayD = todayDate.getDate();

    for (let day = 1; day <= last; day++) {
      const date = new Date(currentYear, currentMonth - 1, day);
      const w = date.getDay();
      const box = document.createElement("div");
      box.className = "calendar-day";
      box.dataset.day = day;
      box.id = "list-day-" + day;

      if (w === 0 || holidays[day]) box.classList.add("sunday");
      else if (w === 6) box.classList.add("saturday");

      if (isThisMonth && day < todayD) {
        box.classList.add("collapsed");
      }

      const weekday = ["日", "月", "火", "水", "木", "金", "土"][w];
      const head = document.createElement("div");
      head.className = "day-head";
      head.onclick = (e) => {
         if(!e.target.closest('.chip')) {
           box.classList.toggle('collapsed');
         }
      };

      const title = document.createElement("div");
      title.className = "day-title";
      title.innerHTML = `${day}日（${weekday}）<span class="toggle-icon">▼</span>`;
      if (holidays[day]) {
        const tag = document.createElement("span");
        tag.className = "holiday-tag";
        tag.textContent = holidays[day];
        title.appendChild(tag);
      }
      head.appendChild(title);
      
      const bodyDiv = document.createElement("div");
      bodyDiv.className = "day-body";

      const sw = document.createElement("div");
      sw.className = "switches";
      const mk = (key, label, dayNo) => {
        const c = document.createElement("div");
        c.className = "chip";
        c.textContent = label;
        c.onclick = (e) => {
          e.stopPropagation();
          schedule[dayNo] = schedule[dayNo] || {
            off: false,
            morning: false,
            afternoon: false,
            after: false,
            note: "",
            place: "",
            time: ""
          };
          const cur = !!schedule[dayNo][key];
          const next = !cur;

          const p = { [key]: next };
          
          // 修正: 「オフ」をONにしたら、活動時間はOFFにする（ユーザーの誤操作防止）
          if (key === "off" && next) {
            p.morning = false;
            p.afternoon = false;
            p.after = false;
            schedule[dayNo].morning = false;
            schedule[dayNo].afternoon = false;
            schedule[dayNo].after = false;
          }
          // 注意: 「活動」をONにしたときに「オフ」をOFFにする処理は削除（オフかつ活動ありを許容）
          
          if (key === "after" && next) {
            const t = (schedule[dayNo].time || "").trim();
            if (!t) {
              const def = defaultAfterTimeRangeForDay(dayNo);
              if (def) {
                schedule[dayNo].time = def;
                queuePatch(String(dayNo), { time: def });
              }
            }
          }
          
          queuePatch(String(dayNo), p);
          schedule[dayNo][key] = next;
          render();
          renderOverviewCalendar();
        };
        return c;
      };
      const cm = mk("morning", "午前", day),
        ca = mk("afternoon", "午後", day),
        cf = mk("after", "業後", day),
        coff = mk("off", "オフ", day);
      if (schedule[day]?.morning) cm.classList.add("on");
      if (schedule[day]?.afternoon) ca.classList.add("on");
      if (schedule[day]?.after) cf.classList.add("on");
      if (schedule[day]?.off) coff.classList.add("on");

      sw.appendChild(cm);
      sw.appendChild(ca);
      sw.appendChild(cf);
      sw.appendChild(coff);
      
      bodyDiv.appendChild(sw);
      
      box.appendChild(head);

      const hasActivity = schedule[day]?.morning || schedule[day]?.afternoon || schedule[day]?.after;
      if (schedule[day]?.off) {
        box.classList.add("off-day");
      } else if (!hasActivity) {
        box.classList.add("undecided");
        title.innerHTML += " <span style='font-weight:normal;font-size:0.9em;'>（未定）</span>";
      }

      bodyDiv.appendChild(makeInputRow("イベント", schedule[day]?.note || "", v => {
        queuePatch(String(day), { note: v });
      }));
      bodyDiv.appendChild(makeInputRow("場所", schedule[day]?.place || "", v => {
        queuePatch(String(day), { place: v });
      }));
      bodyDiv.appendChild(makeTimeRow(day));
      const counts = document.createElement("div");
      counts.className = "counts";
      const A = attendance[day] || {
        morning: [],
        afternoon: [],
        after: [],
        absent: [],
        tardy: [],
        early: []
      };
      const present = new Set([...(A.morning || []), ...(A.afternoon || []), ...(A.after || [])]);
      const absent = (A.absent || []);
      const tardy = (A.tardy || []);
      const early = (A.early || []);
      const answeredCount = present.size + absent.length;
      if (hasActivity && answeredCount >= 8 && present.size <= 4) {
        box.classList.add("low-attendance");
      }

      const presentLabel = schedule[day]?.off ? `希望:${present.size}` : `出席:${present.size}`;
      const b = makeBadge(presentLabel, [...present]);
      if (schedule[day]?.off && present.size > 0) {
           b.classList.add("request");
      }
      counts.appendChild(b);
      
      counts.appendChild(makeBadge(`欠席:${absent.length}`, absent));
      counts.appendChild(makeBadgeSub(`遅刻:${tardy.length}`, tardy));
      counts.appendChild(makeBadgeSub(`早退:${early.length}`, early));
      
      if (!hasActivity && !schedule[day]?.off && present.size === 0) {
          counts.style.opacity = .6;
      }
      bodyDiv.appendChild(counts);
      
      box.appendChild(bodyDiv);
      frag.appendChild(box);
    }
    cont.appendChild(frag);
  }

  function computeAttendanceSummary() {
    const last = new Date(currentYear, currentMonth, 0).getDate();
    const activeDays = [];
    for (let d = 1; d <= last; d++) {
      if (schedule[d]?.morning || schedule[d]?.afternoon || schedule[d]?.after) activeDays.push(d);
    }
    const totalDays = activeDays.length;
    const members = (roster && roster.length) ? roster.slice() : [];
    const map = {};
    members.forEach(n => map[n] = {
      name: n,
      present: 0,
      absent: 0,
      unknown: 0,
      tardy: 0,
      early: 0
    });
    activeDays.forEach(d => {
      const A = attendance[d] || {
        morning: [],
        afternoon: [],
        after: [],
        absent: [],
        tardy: [],
        early: []
      };
      const presentSet = new Set([...(A.morning || []), ...(A.afternoon || []), ...(A.after || [])]);
      const absentArr = A.absent || [];
      const tardySet = new Set(A.tardy || []);
      const earlySet = new Set(A.early || []);
      members.forEach(n => {
        if (presentSet.has(n)) map[n].present++;
        else if (absentArr.includes(n)) map[n].absent++;
        else map[n].unknown++;

        if (tardySet.has(n)) map[n].tardy++;
        if (earlySet.has(n)) map[n].early++;
      });
    });
    const rows = Object.values(map);
    return {
      totalDays,
      rows
    };
  }

  function renderDashboard() {
    const host = document.getElementById("dashboard");
    if (!host) return;
    const { totalDays, rows } = computeAttendanceSummary();
    if (totalDays === 0) {
      host.innerHTML = `<div class="dash-card"><h3>ダッシュボード</h3><div class="meta-line">今月の実施日はありません。</div></div>`;
      return;
    }
    rows.sort((a, b) => {
      const ra = a.present / totalDays,
        rb = b.present / totalDays;
      if (rb !== ra) return rb - ra;
      return (a.name || "").localeCompare(b.name || "", "ja");
    });
    const rowsHtml = rows.map(r => {
      const rate = Math.round((r.present / totalDays) * 1000) / 10;
      const w = Math.max(0, Math.min(100, rate));
      return `<tr onclick="showAdminGraph('${r.name}')" style="cursor:pointer">
      <td class="n" style="text-decoration:underline;color:#a67c52;">${r.name}</td>
      <td class="rate">${rate}%</td>
      <td style="min-width:120px;"><div class="bar"><span style="width:${w}%;"></span></div></td>
      <td class="cnts">出:${r.present}/${totalDays}・欠:${r.absent}・未:${r.unknown} <span class="mini">｜ 遅:${r.tardy}・早:${r.early}</span></td>
    </tr>`;
    }).join("");
    host.innerHTML = `
    <div class="dash-card">
      <h3>ダッシュボード（部員別 出席率 / ${currentYear}年${currentMonth}月）</h3>
      <div class="meta-line">母数＝「実施日」（午前/午後/業後のいずれかがONの日）の日数。遅刻/早退は別集計。</div>
      <table>
        <thead><tr><th class="n">名前</th><th class="rate">出席率</th><th>進捗</th><th>内訳</th></tr></thead>
        <tbody>${rowsHtml}</tbody>
      </table>
    </div>`;
  }

  function flushPatch(_, afterCb) {
    if (Object.keys(unsavedPatch).length === 0) {
      setStatus("変更はありません");
      afterCb && afterCb();
      return;
    }
    const patch = JSON.parse(JSON.stringify(unsavedPatch));
    setLoading(true);
    google.script.run
      .withSuccessHandler(res => {
        if (res && res.schedule) schedule = res.schedule;
        unsavedPatch = {};
        markDirty();
        render();
        renderOverviewCalendar();
        setStatus("登録しました。");
        alert("登録しました。");
        setLoading(false);
        afterCb && afterCb();
      })
      .withFailureHandler(() => {
        alert("登録に失敗しました。通信状況をご確認ください。");
        setLoading(false);
        afterCb && afterCb();
      })
      .saveSchedulePatch(currentYear, currentMonth, patch, "adminUI");
  }

  function halfHourList(startHour, endHour) {
    const arr = [];
    for (let h = startHour; h <= endHour; h++) {
      for (let m of [0, 30]) {
        if (h === endHour && m === 30) continue;
        arr.push(`${('0'+h).slice(-2)}:${('0'+m).slice(-2)}`);
      }
    }
    return arr;
  }

  function makeTimeSelect(value) {
    const sel = document.createElement("select");
    const blank = document.createElement("option");
    blank.value = "";
    blank.textContent = "--:--";
    sel.appendChild(blank);
    HH.forEach(t => {
      const o = document.createElement("option");
      o.value = t;
      o.textContent = t;
      if (t === value) o.selected = true;
      sel.appendChild(o);
    });
    return sel;
  }

  function parseTimeRange(str) {
    const m = String(str || "").match(/^(\d{1,2}):(\d{2})\s*~\s*(\d{1,2}):(\d{2})$/);
    return m ? [`${('0'+m[1]).slice(-2)}:${m[2]}`, `${('0'+m[3]).slice(-2)}:${m[4]}`] : ["", ""];
  }

  function makeTimeRow(day) {
    const row = document.createElement("div");
    row.className = "row";
    const lbl = document.createElement("div");
    lbl.className = "label";
    lbl.textContent = "時間";
    row.appendChild(lbl);
    let [st0, ed0] = parseTimeRange(schedule[day]?.time || "");
    if (!HH.includes(st0)) st0 = "";
    if (!HH.includes(ed0)) ed0 = "";
    const st = makeTimeSelect(st0);
    const sep = document.createElement("div");
    sep.textContent = "~";
    sep.style.minWidth = "1.2em";
    sep.style.textAlign = "center";
    const ed = makeTimeSelect(ed0);
    const onChange = () => {
      let s = st.value,
        e = ed.value;
      if (s && e && s > e) {
        const tmp = s;
        s = e;
        e = tmp;
        st.value = s;
        ed.value = e;
      }
      const v = (s && e) ? `${s}~${e}` : "";
      queuePatch(String(day), { time: v });
      schedule[day].time = v;
    };
    st.addEventListener("change", onChange);
    ed.addEventListener("change", onChange);
    row.appendChild(st);
    row.appendChild(sep);
    row.appendChild(ed);
    return row;
  }

  function makeBadge(text, names) {
    const b = document.createElement("span");
    b.className = "badge";
    b.textContent = text;
    b.title = names.join("\n");
    b.onclick = () => alert(names.length ? `${text.split(':')[0]}:\n${names.join("\n")}` : "該当者なし");
    return b;
  }

  function makeBadgeSub(text, names) {
    const b = document.createElement("span");
    b.className = "badge sub";
    b.textContent = text;
    b.title = names.join("\n");
    b.onclick = () => alert(names.length ? `${text.split(':')[0]}:\n${names.join("\n")}` : "該当者なし");
    return b;
  }

  function makeInputRow(label, value, onChange) {
    const row = document.createElement("div");
    row.className = "row";
    const l = document.createElement("div");
    l.className = "label";
    l.textContent = label;
    const t = document.createElement("input");
    t.type = "text";
    t.value = value;
    t.addEventListener("input", () => {
      onChange(t.value);
    });
    row.appendChild(l);
    row.appendChild(t);
    return row;
  }

  function applyQuick(mode) {
    let targetDays = null;
    if (mode !== "UNDECIDED_OFF") {
      targetDays = [...document.querySelectorAll('#weekdayGroup input:checked')].map(el => parseInt(el.value, 10));
      if (!targetDays.length) {
        alert("曜日を選択してください");
        return;
      }
    }

    const last = new Date(currentYear, currentMonth, 0).getDate();
    const patch = {};
    for (let d = 1; d <= last; d++) {
      if (mode !== "UNDECIDED_OFF") {
        const w = new Date(currentYear, currentMonth - 1, d).getDay();
        if (!targetDays.includes(w)) continue;
      }

      const base = schedule[d] || {
        off: false,
        morning: false,
        afternoon: false,
        after: false,
        note: "",
        place: "",
        time: ""
      };
      if (mode === "UNDECIDED_OFF") {
        const hasActivity = base.morning || base.afternoon || base.after;
        if (!hasActivity && !base.off) {
          patch[d] = { off: true };
        }
      } else if (mode === "M_ON") patch[d] = {
        morning: true,
        afternoon: base.afternoon,
        after: base.after
      };
      else if (mode === "A_ON") patch[d] = {
        morning: base.morning,
        afternoon: true,
        after: base.after
      };
      else if (mode === "F_ON") {
        patch[d] = {
          morning: base.morning,
          afternoon: base.afternoon,
          after: true
        };
        const t = (base.time || "").trim();
        if (!t) {
          const def = defaultAfterTimeRangeForDay(d);
          if (def) {
            (patch[d].time = def);
          }
        }
      } else if (mode === "ALL_OFF") patch[d] = {
        morning: false,
        afternoon: false,
        after: false
      };
    }
    if (!Object.keys(patch).length) {
      alert("変更対象の日がありません");
      return;
    }
    Object.keys(patch).forEach(d => {
      schedule[d] = schedule[d] || {
        morning: false,
        afternoon: false,
        after: false,
        note: "",
        place: "",
        time: ""
      };
      Object.assign(schedule[d], patch[d]);
    });
    Object.keys(patch).forEach(d => queuePatch(String(d), patch[d]));
    markDirty();
    render();
    renderOverviewCalendar();
    setStatus("一括変更をキューに入れました。右下の「登録」を押すと反映されます。");
  }

  window.showAdminGraph = function(name) {
    document.getElementById("adminChartArea").style.display = "block";
    document.getElementById("chartTargetName").textContent = name;
    google.script.run.withSuccessHandler(res => {
      const ctx = document.getElementById('adminChart').getContext('2d');
      if (adminChart) {
        adminChart.destroy();
      }
      adminChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: res.months,
          datasets: [{
            label: name + 'の出席率(%)',
            data: res.rates,
            backgroundColor: '#a67c52',
            borderRadius: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              max: 100
            }
          }
        }
      });
      document.getElementById("adminChartArea").scrollIntoView({
        behavior: "smooth"
      });
    }).getStatsForGraph(name, currentYear, currentMonth, 6);
  };

  const scrollBtn = document.getElementById("scrollTopBtn");
  window.addEventListener("scroll", () => {
    if (window.scrollY > 200) scrollBtn.classList.add("show");
    else scrollBtn.classList.remove("show");
  });
  scrollBtn.addEventListener("click", () => {
    window.scrollTo({
      top: 0,
      behavior: "smooth"
    });
  });
</script>